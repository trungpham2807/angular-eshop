import { Injectable } from '@angular/core';
import { Actions, ofType } from '@ngrx/effects';
import { ROUTER_NAVIGATION } from '@ngrx/router-store';
import { Store } from '@ngrx/store';
import { isObservable, of } from 'rxjs';
import { catchError, concatMap, filter, groupBy, map, mergeMap, switchMap, withLatestFrom, } from 'rxjs/operators';
export function pessimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
export function optimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.undoAction)));
    };
}
export function fetch(opts) {
    return (source) => {
        if (opts.id) {
            const groupedFetches = source.pipe(mapActionAndState(), groupBy(([action, store]) => {
                return opts.id(action, store);
            }));
            return groupedFetches.pipe(mergeMap((pairs) => pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)))));
        }
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
export function navigation(component, opts) {
    return (source) => {
        const nav = source.pipe(mapActionAndState(), filter(([action, state]) => isStateSnapshot(action)), map(([action, state]) => {
            if (!isStateSnapshot(action)) {
                // Because of the above filter we'll never get here,
                // but this properly type narrows `action`
                return;
            }
            return [
                findSnapshot(component, action.payload.routerState.root),
                state,
            ];
        }), filter(([snapshot, state]) => !!snapshot));
        return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
function isStateSnapshot(action) {
    return action.type === ROUTER_NAVIGATION;
}
function runWithErrorHandling(run, onError) {
    return ([action, state]) => {
        try {
            const r = wrapIntoObservable(run(action, state));
            return r.pipe(catchError((e) => wrapIntoObservable(onError(action, e))));
        }
        catch (e) {
            return wrapIntoObservable(onError(action, e));
        }
    };
}
/**
 * @whatItDoes maps Observable<Action | [Action, State]> to
 * Observable<[Action, State]>
 */
function mapActionAndState() {
    return (source) => {
        return source.pipe(map((value) => {
            const [action, store] = normalizeActionAndState(value);
            return [action, store];
        }));
    };
}
/**
 * @whatItDoes Normalizes either a bare action or an array of action and state
 * into an array of action and state (or undefined)
 */
function normalizeActionAndState(args) {
    let action, state;
    if (args instanceof Array) {
        [action, state] = args;
    }
    else {
        action = args;
    }
    return [action, state];
}
/**
 * @whatItDoes Provides convenience methods for implementing common operations of persisting data.
 */
export class DataPersistence {
    constructor(store, actions) {
        this.store = store;
        this.actions = actions;
    }
    /**
     *
     * @whatItDoes Handles pessimistic updates (updating the server first).
     *
     * Update the server implemented naively suffers from race conditions and poor error handling.
     *
     * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run(a, state) {
     *       // update the backend first, and then dispatch an action that will
     *       // update the client side
     *       return this.backend(state.user, a.payload).map(updated => ({
     *         type: 'TODO_UPDATED',
     *         payload: updated
     *       }));
     *     },
     *
     *     onError(a, e: any) {
     *       // we don't need to undo the changes on the client side.
     *       // we can dispatch an error, or simply log the error here and return `null`
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     *   @Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     */
    pessimisticUpdate(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), pessimisticUpdate(opts));
    }
    /**
     *
     * @whatItDoes Handles optimistic updates (updating the client first).
     *
     * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
     * the developer already updated the state locally, so the developer must provide an undo action.
     *
     * The error handling must be done in the callback, or by means of the undo action.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload);
     *     },
     *
     *     undoAction: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return ({
     *         type: 'UNDO_UPDATE_TODO',
     *         payload: a
     *       });
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     *   @Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     */
    optimisticUpdate(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), optimisticUpdate(opts));
    }
    /**
     *
     * @whatItDoes Handles data fetching.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODOS',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * This is correct, but because it set the concurrency to 1, it may not be performant.
     *
     * To fix that, you can provide the `id` function, like this:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
     *     id: (a, state) => {
     *       return a.payload.id;
     *     }
     *
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODO',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
     *
     * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
     * it will only run the last one.
     */
    fetch(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), fetch(opts));
    }
    /**
     * @whatItDoes Handles data fetching as part of router navigation.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `navigation` addresses these problems.
     *
     * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
     * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
     * the last request.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodo = this.s.navigation(TodoComponent, {
     *     run: (a, state) => {
     *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
     *         type: 'TODO_LOADED',
     *         payload: todo
     *       }));
     *     },
     *     onError: (a, e: any) => {
     *       // we can log and error here and return null
     *       // we can also navigate back
     *       return null;
     *     }
     *   });
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     */
    navigation(component, opts) {
        return this.actions.pipe(withLatestFrom(this.store), navigation(component, opts));
    }
}
DataPersistence.decorators = [
    { type: Injectable }
];
DataPersistence.ctorParameters = () => [
    { type: Store },
    { type: Actions }
];
function findSnapshot(component, s) {
    if (s.routeConfig && s.routeConfig.component === component) {
        return s;
    }
    for (const c of s.children) {
        const ss = findSnapshot(component, c);
        if (ss) {
            return ss;
        }
    }
    return null;
}
function wrapIntoObservable(obj) {
    if (isObservable(obj)) {
        return obj;
    }
    else if (!obj) {
        return of();
    }
    else {
        return of(obj);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1wZXJzaXN0ZW5jZS5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS92c2F2a2luL3Byb2plY3RzL254L3BhY2thZ2VzL2FuZ3VsYXIvIiwic291cmNlcyI6WyJzcmMvcnVudGltZS9ueC9kYXRhLXBlcnNpc3RlbmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQVEsTUFBTSxlQUFlLENBQUM7QUFFakQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEQsT0FBTyxFQUFFLGlCQUFpQixFQUEwQixNQUFNLG9CQUFvQixDQUFDO0FBQy9FLE9BQU8sRUFBVSxLQUFLLEVBQWlCLE1BQU0sYUFBYSxDQUFDO0FBQzNELE9BQU8sRUFBRSxZQUFZLEVBQWMsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3BELE9BQU8sRUFDTCxVQUFVLEVBQ1YsU0FBUyxFQUNULE1BQU0sRUFDTixPQUFPLEVBQ1AsR0FBRyxFQUNILFFBQVEsRUFDUixTQUFTLEVBQ1QsY0FBYyxHQUNmLE1BQU0sZ0JBQWdCLENBQUM7QUFxQ3hCLE1BQU0sVUFBVSxpQkFBaUIsQ0FDL0IsSUFBaUM7SUFFakMsT0FBTyxDQUFDLE1BQStCLEVBQXNCLEVBQUU7UUFDN0QsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUNoQixpQkFBaUIsRUFBRSxFQUNuQixTQUFTLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FDeEQsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLFVBQVUsZ0JBQWdCLENBQzlCLElBQWdDO0lBRWhDLE9BQU8sQ0FBQyxNQUErQixFQUFzQixFQUFFO1FBQzdELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FDaEIsaUJBQWlCLEVBQUUsRUFDbkIsU0FBUyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFB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QUMxRCxPQUFPLENBQUMsQ0FBQztLQUNWO0lBQ0QsS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFO1FBQzFCLE1BQU0sRUFBRSxHQUFHLFlBQVksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDdEMsSUFBSSxFQUFFLEVBQUU7WUFDTixPQUFPLEVBQUUsQ0FBQztTQUNYO0tBQ0Y7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFFRCxTQUFTLGtCQUFrQixDQUFJLEdBQTZCO0lBQzFELElBQUksWUFBWSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3JCLE9BQU8sR0FBRyxDQUFDO0tBQ1o7U0FBTSxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ2YsT0FBTyxFQUFFLEVBQUUsQ0FBQztLQUNiO1NBQU07UUFDTCxPQUFPLEVBQUUsQ0FBQyxHQUFRLENBQUMsQ0FBQztLQUNyQjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBSb3V0ZXJTdGF0ZVNuYXBzaG90IH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEFjdGlvbnMsIG9mVHlwZSB9IGZyb20gJ0BuZ3J4L2VmZmVjdHMnO1xuaW1wb3J0IHsgUk9VVEVSX05BVklHQVRJT04sIFJvdXRlck5hdmlnYXRpb25BY3Rpb24gfSBmcm9tICdAbmdyeC9yb3V0ZXItc3RvcmUnO1xuaW1wb3J0IHsgQWN0aW9uLCBTdG9yZSwgQWN0aW9uQ3JlYXRvciB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcbmltcG9ydCB7IGlzT2JzZXJ2YWJsZSwgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGNvbmNhdE1hcCxcbiAgZmlsdGVyLFxuICBncm91cEJ5LFxuICBtYXAsXG4gIG1lcmdlTWFwLFxuICBzd2l0Y2hNYXAsXG4gIHdpdGhMYXRlc3RGcm9tLFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogU2VlIHtAbGluayBEYXRhUGVyc2lzdGVuY2UucGVzc2ltaXN0aWNVcGRhdGV9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBlc3NpbWlzdGljVXBkYXRlT3B0czxULCBBPiB7XG4gIHJ1bihhOiBBLCBzdGF0ZT86IFQpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICBvbkVycm9yKGE6IEEsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cbi8qKlxuICogU2VlIHtAbGluayBEYXRhUGVyc2lzdGVuY2UucGVzc2ltaXN0aWNVcGRhdGV9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9wdGltaXN0aWNVcGRhdGVPcHRzPFQsIEE+IHtcbiAgcnVuKGE6IEEsIHN0YXRlPzogVCk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIHVuZG9BY3Rpb24oYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uO1xufVxuXG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YVBlcnNpc3RlbmNlLmZldGNofSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGZXRjaE9wdHM8VCwgQT4ge1xuICBpZD8oYTogQSwgc3RhdGU/OiBUKTogYW55O1xuICBydW4oYTogQSwgc3RhdGU/OiBUKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgb25FcnJvcj8oYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHwgYW55O1xufVxuXG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YVBlcnNpc3RlbmNlLm5hdmlnYXRpb259IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhhbmRsZU5hdmlnYXRpb25PcHRzPFQ+IHtcbiAgcnVuKGE6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIHN0YXRlPzogVCk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIG9uRXJyb3I/KGE6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cblxuZXhwb3J0IHR5cGUgQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT4gPSBBIHwgW0EsIFRdO1xuZXhwb3J0IHR5cGUgQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4gPSBPYnNlcnZhYmxlPEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlPFQsIEE+PjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBlc3NpbWlzdGljVXBkYXRlPFQsIEEgZXh0ZW5kcyBBY3Rpb24+KFxuICBvcHRzOiBQZXNzaW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pOiBPYnNlcnZhYmxlPEFjdGlvbj4gPT4ge1xuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBjb25jYXRNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMub25FcnJvcikpXG4gICAgKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGltaXN0aWNVcGRhdGU8VCwgQSBleHRlbmRzIEFjdGlvbj4oXG4gIG9wdHM6IE9wdGltaXN0aWNVcGRhdGVPcHRzPFQsIEE+XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlU3RyZWFtPFQsIEE+KTogT2JzZXJ2YWJsZTxBY3Rpb24+ID0+IHtcbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgY29uY2F0TWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLnVuZG9BY3Rpb24pKVxuICAgICk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaDxULCBBIGV4dGVuZHMgQWN0aW9uPihvcHRzOiBGZXRjaE9wdHM8VCwgQT4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlU3RyZWFtPFQsIEE+KTogT2JzZXJ2YWJsZTxBY3Rpb24+ID0+IHtcbiAgICBpZiAob3B0cy5pZCkge1xuICAgICAgY29uc3QgZ3JvdXBlZEZldGNoZXMgPSBzb3VyY2UucGlwZShcbiAgICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgICAgZ3JvdXBCeSgoW2FjdGlvbiwgc3RvcmVdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9wdHMuaWQoYWN0aW9uLCBzdG9yZSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZ3JvdXBlZEZldGNoZXMucGlwZShcbiAgICAgICAgbWVyZ2VNYXAoKHBhaXJzKSA9PlxuICAgICAgICAgIHBhaXJzLnBpcGUoc3dpdGNoTWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgY29uY2F0TWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKVxuICAgICk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYXZpZ2F0aW9uPFQsIEEgZXh0ZW5kcyBBY3Rpb24+KFxuICBjb21wb25lbnQ6IFR5cGU8YW55PixcbiAgb3B0czogSGFuZGxlTmF2aWdhdGlvbk9wdHM8VD5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pID0+IHtcbiAgICBjb25zdCBuYXYgPSBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBmaWx0ZXIoKFthY3Rpb24sIHN0YXRlXSkgPT4gaXNTdGF0ZVNuYXBzaG90KGFjdGlvbikpLFxuICAgICAgbWFwKChbYWN0aW9uLCBzdGF0ZV0pID0+IHtcbiAgICAgICAgaWYgKCFpc1N0YXRlU25hcHNob3QoYWN0aW9uKSkge1xuICAgICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhlIGFib3ZlIGZpbHRlciB3ZSdsbCBuZXZlciBnZXQgaGVyZSxcbiAgICAgICAgICAvLyBidXQgdGhpcyBwcm9wZXJseSB0eXBlIG5hcnJvd3MgYGFjdGlvbmBcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGZpbmRTbmFwc2hvdChjb21wb25lbnQsIGFjdGlvbi5wYXlsb2FkLnJvdXRlclN0YXRlLnJvb3QpLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICBdIGFzIFtBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBUXTtcbiAgICAgIH0pLFxuICAgICAgZmlsdGVyKChbc25hcHNob3QsIHN0YXRlXSkgPT4gISFzbmFwc2hvdClcbiAgICApO1xuXG4gICAgcmV0dXJuIG5hdi5waXBlKHN3aXRjaE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc1N0YXRlU25hcHNob3QoXG4gIGFjdGlvbjogYW55XG4pOiBhY3Rpb24gaXMgUm91dGVyTmF2aWdhdGlvbkFjdGlvbjxSb3V0ZXJTdGF0ZVNuYXBzaG90PiB7XG4gIHJldHVybiBhY3Rpb24udHlwZSA9PT0gUk9VVEVSX05BVklHQVRJT047XG59XG5cbmZ1bmN0aW9uIHJ1bldpdGhFcnJvckhhbmRsaW5nPFQsIEEsIFI+KFxuICBydW46IChhOiBBLCBzdGF0ZT86IFQpID0+IE9ic2VydmFibGU8Uj4gfCBSIHwgdm9pZCxcbiAgb25FcnJvcjogYW55XG4pIHtcbiAgcmV0dXJuIChbYWN0aW9uLCBzdGF0ZV06IFtBLCBUXSk6IE9ic2VydmFibGU8Uj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByID0gd3JhcEludG9PYnNlcnZhYmxlKHJ1bihhY3Rpb24sIHN0YXRlKSk7XG4gICAgICByZXR1cm4gci5waXBlKGNhdGNoRXJyb3IoKGUpID0+IHdyYXBJbnRvT2JzZXJ2YWJsZShvbkVycm9yKGFjdGlvbiwgZSkpKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHdyYXBJbnRvT2JzZXJ2YWJsZShvbkVycm9yKGFjdGlvbiwgZSkpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAd2hhdEl0RG9lcyBtYXBzIE9ic2VydmFibGU8QWN0aW9uIHwgW0FjdGlvbiwgU3RhdGVdPiB0b1xuICogT2JzZXJ2YWJsZTxbQWN0aW9uLCBTdGF0ZV0+XG4gKi9cbmZ1bmN0aW9uIG1hcEFjdGlvbkFuZFN0YXRlPFQsIEE+KCkge1xuICByZXR1cm4gKHNvdXJjZTogT2JzZXJ2YWJsZTxBY3Rpb25PckFjdGlvbldpdGhTdGF0ZTxULCBBPj4pID0+IHtcbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IFthY3Rpb24sIHN0b3JlXSA9IG5vcm1hbGl6ZUFjdGlvbkFuZFN0YXRlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIFthY3Rpb24sIHN0b3JlXSBhcyBbQSwgVF07XG4gICAgICB9KVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogQHdoYXRJdERvZXMgTm9ybWFsaXplcyBlaXRoZXIgYSBiYXJlIGFjdGlvbiBvciBhbiBhcnJheSBvZiBhY3Rpb24gYW5kIHN0YXRlXG4gKiBpbnRvIGFuIGFycmF5IG9mIGFjdGlvbiBhbmQgc3RhdGUgKG9yIHVuZGVmaW5lZClcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQWN0aW9uQW5kU3RhdGU8VCwgQT4oXG4gIGFyZ3M6IEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlPFQsIEE+XG4pOiBbQSwgVF0ge1xuICBsZXQgYWN0aW9uOiBBLCBzdGF0ZTogVDtcblxuICBpZiAoYXJncyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgW2FjdGlvbiwgc3RhdGVdID0gYXJncztcbiAgfSBlbHNlIHtcbiAgICBhY3Rpb24gPSBhcmdzO1xuICB9XG5cbiAgcmV0dXJuIFthY3Rpb24sIHN0YXRlXTtcbn1cblxuLyoqXG4gKiBAd2hhdEl0RG9lcyBQcm92aWRlcyBjb252ZW5pZW5jZSBtZXRob2RzIGZvciBpbXBsZW1lbnRpbmcgY29tbW9uIG9wZXJhdGlvbnMgb2YgcGVyc2lzdGluZyBkYXRhLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0YVBlcnNpc3RlbmNlPFQ+IHtcbiAgY29uc3RydWN0b3IocHVibGljIHN0b3JlOiBTdG9yZTxUPiwgcHVibGljIGFjdGlvbnM6IEFjdGlvbnMpIHt9XG5cbiAgLyoqXG4gICAqXG4gICAqIEB3aGF0SXREb2VzIEhhbmRsZXMgcGVzc2ltaXN0aWMgdXBkYXRlcyAodXBkYXRpbmcgdGhlIHNlcnZlciBmaXJzdCkuXG4gICAqXG4gICAqIFVwZGF0ZSB0aGUgc2VydmVyIGltcGxlbWVudGVkIG5haXZlbHkgc3VmZmVycyBmcm9tIHJhY2UgY29uZGl0aW9ucyBhbmQgcG9vciBlcnJvciBoYW5kbGluZy5cbiAgICpcbiAgICogYHBlc3NpbWlzdGljVXBkYXRlYCBhZGRyZXNzZXMgdGhlc2UgcHJvYmxlbXMtLWl0IHJ1bnMgYWxsIGZldGNoZXMgaW4gb3JkZXIsIHdoaWNoIHJlbW92ZXMgcmFjZSBjb25kaXRpb25zXG4gICAqIGFuZCBmb3JjZXMgdGhlIGRldmVsb3BlciB0byBoYW5kbGUgZXJyb3JzLlxuICAgKlxuICAgKiAjIyBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIEBJbmplY3RhYmxlKClcbiAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgKiAgIEBFZmZlY3QoKSB1cGRhdGVUb2RvID0gdGhpcy5zLnBlc3NpbWlzdGljVXBkYXRlPFVwZGF0ZVRvZG8+KCdVUERBVEVfVE9ETycsIHtcbiAgICogICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN0b3JlXG4gICAqICAgICBydW4oYSwgc3RhdGUpIHtcbiAgICogICAgICAgLy8gdXBkYXRlIHRoZSBiYWNrZW5kIGZpcnN0LCBhbmQgdGhlbiBkaXNwYXRjaCBhbiBhY3Rpb24gdGhhdCB3aWxsXG4gICAqICAgICAgIC8vIHVwZGF0ZSB0aGUgY2xpZW50IHNpZGVcbiAgICogICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZChzdGF0ZS51c2VyLCBhLnBheWxvYWQpLm1hcCh1cGRhdGVkID0+ICh7XG4gICAqICAgICAgICAgdHlwZTogJ1RPRE9fVVBEQVRFRCcsXG4gICAqICAgICAgICAgcGF5bG9hZDogdXBkYXRlZFxuICAgKiAgICAgICB9KSk7XG4gICAqICAgICB9LFxuICAgKlxuICAgKiAgICAgb25FcnJvcihhLCBlOiBhbnkpIHtcbiAgICogICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byB1bmRvIHRoZSBjaGFuZ2VzIG9uIHRoZSBjbGllbnQgc2lkZS5cbiAgICogICAgICAgLy8gd2UgY2FuIGRpc3BhdGNoIGFuIGVycm9yLCBvciBzaW1wbHkgbG9nIHRoZSBlcnJvciBoZXJlIGFuZCByZXR1cm4gYG51bGxgXG4gICAqICAgICAgIHJldHVybiBudWxsO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgczogRGF0YVBlcnNpc3RlbmNlPFRvZG9zU3RhdGU+LCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZG9uJ3QgcmV0dXJuIGEgbmV3IGFjdGlvbiBmcm9tIHRoZSBydW4gY2FsbGJhY2ssIHlvdSBtdXN0IHNldCB0aGUgZGlzcGF0Y2ggcHJvcGVydHlcbiAgICogb2YgdGhlIGVmZmVjdCB0byBmYWxzZSwgbGlrZSB0aGlzOlxuICAgKlxuICAgKiBgYGBcbiAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgKiAgIEBFZmZlY3Qoe2Rpc3BhdGNoOiBmYWxzZX0pXG4gICAqICAgdXBkYXRlVG9kbzsgLy8uLi5cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIHBlc3NpbWlzdGljVXBkYXRlPEEgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24+KFxuICAgIGFjdGlvblR5cGU6IHN0cmluZyB8IEFjdGlvbkNyZWF0b3IsXG4gICAgb3B0czogUGVzc2ltaXN0aWNVcGRhdGVPcHRzPFQsIEE+XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5waXBlKFxuICAgICAgb2ZUeXBlPEE+KGFjdGlvblR5cGUpLFxuICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5zdG9yZSksXG4gICAgICBwZXNzaW1pc3RpY1VwZGF0ZShvcHRzKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHdoYXRJdERvZXMgSGFuZGxlcyBvcHRpbWlzdGljIHVwZGF0ZXMgKHVwZGF0aW5nIHRoZSBjbGllbnQgZmlyc3QpLlxuICAgKlxuICAgKiBgb3B0aW1pc3RpY1VwZGF0ZWAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLS1pdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9uc1xuICAgKiBhbmQgZm9yY2VzIHRoZSBkZXZlbG9wZXIgdG8gaGFuZGxlIGVycm9ycy5cbiAgICpcbiAgICogYG9wdGltaXN0aWNVcGRhdGVgIGlzIGRpZmZlcmVudCBmcm9tIGBwZXNzaW1pc3RpY1VwZGF0ZWAuIEluIGNhc2Ugb2YgYSBmYWlsdXJlLCB3aGVuIHVzaW5nIGBvcHRpbWlzdGljVXBkYXRlYCxcbiAgICogdGhlIGRldmVsb3BlciBhbHJlYWR5IHVwZGF0ZWQgdGhlIHN0YXRlIGxvY2FsbHksIHNvIHRoZSBkZXZlbG9wZXIgbXVzdCBwcm92aWRlIGFuIHVuZG8gYWN0aW9uLlxuICAgKlxuICAgKiBUaGUgZXJyb3IgaGFuZGxpbmcgbXVzdCBiZSBkb25lIGluIHRoZSBjYWxsYmFjaywgb3IgYnkgbWVhbnMgb2YgdGhlIHVuZG8gYWN0aW9uLlxuICAgKlxuICAgKiAjIyBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIEBJbmplY3RhYmxlKClcbiAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgKiAgIEBFZmZlY3QoKSB1cGRhdGVUb2RvID0gdGhpcy5zLm9wdGltaXN0aWNVcGRhdGU8VXBkYXRlVG9kbz4oJ1VQREFURV9UT0RPJywge1xuICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICogICAgIHJ1bjogKGEsIHN0YXRlKSA9PiB7XG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQoc3RhdGUudXNlciwgYS5wYXlsb2FkKTtcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICB1bmRvQWN0aW9uOiAoYSwgZTogYW55KSA9PiB7XG4gICAqICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICAgKiAgICAgICByZXR1cm4gKHtcbiAgICogICAgICAgICB0eXBlOiAnVU5ET19VUERBVEVfVE9ETycsXG4gICAqICAgICAgICAgcGF5bG9hZDogYVxuICAgKiAgICAgICB9KTtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHM6IERhdGFQZXJzaXN0ZW5jZTxUb2Rvc1N0YXRlPiwgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRvbid0IHJldHVybiBhIG5ldyBhY3Rpb24gZnJvbSB0aGUgcnVuIGNhbGxiYWNrLCB5b3UgbXVzdCBzZXQgdGhlIGRpc3BhdGNoIHByb3BlcnR5XG4gICAqIG9mIHRoZSBlZmZlY3QgdG8gZmFsc2UsIGxpa2UgdGhpczpcbiAgICpcbiAgICogYGBgXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KHtkaXNwYXRjaDogZmFsc2V9KVxuICAgKiAgIHVwZGF0ZVRvZG87IC8vLi4uXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBvcHRpbWlzdGljVXBkYXRlPEEgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24+KFxuICAgIGFjdGlvblR5cGU6IHN0cmluZyB8IEFjdGlvbkNyZWF0b3IsXG4gICAgb3B0czogT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT5cbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnBpcGUoXG4gICAgICBvZlR5cGU8QT4oYWN0aW9uVHlwZSksXG4gICAgICB3aXRoTGF0ZXN0RnJvbSh0aGlzLnN0b3JlKSxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGUob3B0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEB3aGF0SXREb2VzIEhhbmRsZXMgZGF0YSBmZXRjaGluZy5cbiAgICpcbiAgICogRGF0YSBmZXRjaGluZyBpbXBsZW1lbnRlZCBuYWl2ZWx5IHN1ZmZlcnMgZnJvbSByYWNlIGNvbmRpdGlvbnMgYW5kIHBvb3IgZXJyb3IgaGFuZGxpbmcuXG4gICAqXG4gICAqIGBmZXRjaGAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLS1pdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9uc1xuICAgKiBhbmQgZm9yY2VzIHRoZSBkZXZlbG9wZXIgdG8gaGFuZGxlIGVycm9ycy5cbiAgICpcbiAgICogIyMgRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgbG9hZFRvZG9zID0gdGhpcy5zLmZldGNoPEdldFRvZG9zPignR0VUX1RPRE9TJywge1xuICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICogICAgIHJ1bjogKGEsIHN0YXRlKSA9PiB7XG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQoc3RhdGUudXNlciwgYS5wYXlsb2FkKS5tYXAociA9PiAoe1xuICAgKiAgICAgICAgIHR5cGU6ICdUT0RPUycsXG4gICAqICAgICAgICAgcGF5bG9hZDogclxuICAgKiAgICAgICB9KTtcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICBvbkVycm9yOiAoYSwgZTogYW55KSA9PiB7XG4gICAqICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgczogRGF0YVBlcnNpc3RlbmNlPFRvZG9zU3RhdGU+LCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFRoaXMgaXMgY29ycmVjdCwgYnV0IGJlY2F1c2UgaXQgc2V0IHRoZSBjb25jdXJyZW5jeSB0byAxLCBpdCBtYXkgbm90IGJlIHBlcmZvcm1hbnQuXG4gICAqXG4gICAqIFRvIGZpeCB0aGF0LCB5b3UgY2FuIHByb3ZpZGUgdGhlIGBpZGAgZnVuY3Rpb24sIGxpa2UgdGhpczpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgbG9hZFRvZG8gPSB0aGlzLnMuZmV0Y2g8R2V0VG9kbz4oJ0dFVF9UT0RPJywge1xuICAgKiAgICAgaWQ6IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gYS5wYXlsb2FkLmlkO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICogICAgIHJ1bjogKGEsIHN0YXRlKSA9PiB7XG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQoc3RhdGUudXNlciwgYS5wYXlsb2FkKS5tYXAociA9PiAoe1xuICAgKiAgICAgICAgIHR5cGU6ICdUT0RPJyxcbiAgICogICAgICAgICBwYXlsb2FkOiByXG4gICAqICAgICAgIH0pO1xuICAgKiAgICAgfSxcbiAgICpcbiAgICogICAgIG9uRXJyb3I6IChhLCBlOiBhbnkpID0+IHtcbiAgICogICAgICAgLy8gZGlzcGF0Y2ggYW4gdW5kbyBhY3Rpb24gdG8gdW5kbyB0aGUgY2hhbmdlcyBpbiB0aGUgY2xpZW50IHN0YXRlXG4gICAqICAgICAgIHJldHVybiBudWxsO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgczogRGF0YVBlcnNpc3RlbmNlPFRvZG9zU3RhdGU+LCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFdpdGggdGhpcyBzZXR1cCwgdGhlIHJlcXVlc3RzIGZvciBUb2RvIDEgd2lsbCBydW4gY29uY3VycmVudGx5IHdpdGggdGhlIHJlcXVlc3RzIGZvciBUb2RvIDIuXG4gICAqXG4gICAqIEluIGFkZGl0aW9uLCBpZiBEYXRhUGVyc2lzdGVuY2Ugbm90aWNlcyB0aGF0IHRoZXJlIGFyZSBtdWx0aXBsZSByZXF1ZXN0cyBmb3IgVG9kbyAxIHNjaGVkdWxlZCxcbiAgICogaXQgd2lsbCBvbmx5IHJ1biB0aGUgbGFzdCBvbmUuXG4gICAqL1xuICBmZXRjaDxBIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uPihcbiAgICBhY3Rpb25UeXBlOiBzdHJpbmcgfCBBY3Rpb25DcmVhdG9yLFxuICAgIG9wdHM6IEZldGNoT3B0czxULCBBPlxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnMucGlwZShcbiAgICAgIG9mVHlwZTxBPihhY3Rpb25UeXBlKSxcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuc3RvcmUpLFxuICAgICAgZmV0Y2gob3B0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEB3aGF0SXREb2VzIEhhbmRsZXMgZGF0YSBmZXRjaGluZyBhcyBwYXJ0IG9mIHJvdXRlciBuYXZpZ2F0aW9uLlxuICAgKlxuICAgKiBEYXRhIGZldGNoaW5nIGltcGxlbWVudGVkIG5haXZlbHkgc3VmZmVycyBmcm9tIHJhY2UgY29uZGl0aW9ucyBhbmQgcG9vciBlcnJvciBoYW5kbGluZy5cbiAgICpcbiAgICogYG5hdmlnYXRpb25gIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy5cbiAgICpcbiAgICogSXQgY2hlY2tzIGlmIGFuIGFjdGl2YXRlZCByb3V0ZXIgc3RhdGUgY29udGFpbnMgdGhlIHBhc3NlZCBpbiBjb21wb25lbnQgdHlwZSwgYW5kLCBpZiBpdCBkb2VzLCBydW5zIHRoZSBgcnVuYFxuICAgKiBjYWxsYmFjay4gSXQgcHJvdmlkZXMgdGhlIGFjdGl2YXRlZCBzbmFwc2hvdCBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbXBvbmVudCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUuIEFuZCBpdCBvbmx5IHJ1bnNcbiAgICogdGhlIGxhc3QgcmVxdWVzdC5cbiAgICpcbiAgICogIyMgRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgbG9hZFRvZG8gPSB0aGlzLnMubmF2aWdhdGlvbihUb2RvQ29tcG9uZW50LCB7XG4gICAqICAgICBydW46IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmZldGNoVG9kbyhhLnBhcmFtc1snaWQnXSkubWFwKHRvZG8gPT4gKHtcbiAgICogICAgICAgICB0eXBlOiAnVE9ET19MT0FERUQnLFxuICAgKiAgICAgICAgIHBheWxvYWQ6IHRvZG9cbiAgICogICAgICAgfSkpO1xuICAgKiAgICAgfSxcbiAgICogICAgIG9uRXJyb3I6IChhLCBlOiBhbnkpID0+IHtcbiAgICogICAgICAgLy8gd2UgY2FuIGxvZyBhbmQgZXJyb3IgaGVyZSBhbmQgcmV0dXJuIG51bGxcbiAgICogICAgICAgLy8gd2UgY2FuIGFsc28gbmF2aWdhdGUgYmFja1xuICAgKiAgICAgICByZXR1cm4gbnVsbDtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHM6IERhdGFQZXJzaXN0ZW5jZTxUb2Rvc1N0YXRlPiwgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgbmF2aWdhdGlvbihcbiAgICBjb21wb25lbnQ6IFR5cGU8YW55PixcbiAgICBvcHRzOiBIYW5kbGVOYXZpZ2F0aW9uT3B0czxUPlxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnMucGlwZShcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuc3RvcmUpLFxuICAgICAgbmF2aWdhdGlvbihjb21wb25lbnQsIG9wdHMpXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kU25hcHNob3QoXG4gIGNvbXBvbmVudDogVHlwZTxhbnk+LFxuICBzOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90XG4pOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IHtcbiAgaWYgKHMucm91dGVDb25maWcgJiYgcy5yb3V0ZUNvbmZpZy5jb21wb25lbnQgPT09IGNvbXBvbmVudCkge1xuICAgIHJldHVybiBzO1xuICB9XG4gIGZvciAoY29uc3QgYyBvZiBzLmNoaWxkcmVuKSB7XG4gICAgY29uc3Qgc3MgPSBmaW5kU25hcHNob3QoY29tcG9uZW50LCBjKTtcbiAgICBpZiAoc3MpIHtcbiAgICAgIHJldHVybiBzcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHdyYXBJbnRvT2JzZXJ2YWJsZTxPPihvYmo6IE9ic2VydmFibGU8Tz4gfCBPIHwgdm9pZCk6IE9ic2VydmFibGU8Tz4ge1xuICBpZiAoaXNPYnNlcnZhYmxlKG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2UgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gb2YoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2Yob2JqIGFzIE8pO1xuICB9XG59XG4iXX0=