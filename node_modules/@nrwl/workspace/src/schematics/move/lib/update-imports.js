"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateImports = void 0;
const workspace_1 = require("@nrwl/workspace");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const ts = require("typescript");
const utils_1 = require("./utils");
/**
 * Updates all the imports in the workspace and modifies the tsconfig appropriately.
 *
 * @param schema The options provided to the schematic
 */
function updateImports(schema) {
    return (tree, _context) => {
        return rxjs_1.from(workspace_1.getWorkspace(tree)).pipe(operators_1.map((workspace) => {
            var _a;
            const nxJson = workspace_1.readJsonInTree(tree, 'nx.json');
            const libsDir = ((_a = nxJson.workspaceLayout) === null || _a === void 0 ? void 0 : _a.libsDir) ? nxJson.workspaceLayout.libsDir
                : 'libs';
            const project = workspace.projects.get(schema.projectName);
            if (project.extensions['projectType'] === 'application') {
                // These shouldn't be imported anywhere?
                return tree;
            }
            // use the source root to find the from location
            // this attempts to account for libs that have been created with --importPath
            const tsConfigPath = 'tsconfig.base.json';
            let tsConfig;
            let fromPath;
            if (tree.exists(tsConfigPath)) {
                tsConfig = JSON.parse(tree.read(tsConfigPath).toString('utf-8'));
                fromPath = Object.keys(tsConfig.compilerOptions.paths).find((path) => tsConfig.compilerOptions.paths[path].some((x) => x.startsWith(project.sourceRoot)));
            }
            const projectRef = {
                from: fromPath ||
                    utils_1.normalizeSlashes(`@${nxJson.npmScope}/${project.root.substr(libsDir.length + 1)}`),
                to: schema.importPath ||
                    utils_1.normalizeSlashes(`@${nxJson.npmScope}/${schema.destination}`),
            };
            if (schema.updateImportPath) {
                const replaceProjectRef = new RegExp(projectRef.from, 'g');
                for (const [name, definition] of workspace.projects.entries()) {
                    if (name === schema.projectName) {
                        continue;
                    }
                    const projectDir = tree.getDir(definition.root);
                    projectDir.visit((file) => {
                        const contents = tree.read(file).toString('utf-8');
                        if (!replaceProjectRef.test(contents)) {
                            return;
                        }
                        updateImportPaths(tree, file, contents, projectRef.from, projectRef.to);
                    });
                }
            }
            const projectRoot = {
                from: project.root.substr(libsDir.length + 1),
                to: schema.destination,
            };
            if (tsConfig) {
                const path = tsConfig.compilerOptions.paths[projectRef.from];
                if (!path) {
                    throw new Error([
                        `unable to find "${projectRef.from}" in`,
                        `${tsConfigPath} compilerOptions.paths`,
                    ].join(' '));
                }
                const updatedPath = path.map((x) => x.replace(new RegExp(projectRoot.from, 'g'), projectRoot.to));
                if (schema.updateImportPath) {
                    tsConfig.compilerOptions.paths[projectRef.to] = updatedPath;
                    delete tsConfig.compilerOptions.paths[projectRef.from];
                }
                else {
                    tsConfig.compilerOptions.paths[projectRef.from] = updatedPath;
                }
                tree.overwrite(tsConfigPath, workspace_1.serializeJson(tsConfig));
            }
            return tree;
        }));
    };
}
exports.updateImports = updateImports;
function updateImportPaths(tree, path, contents, from, to) {
    const sourceFile = ts.createSourceFile(path, contents, ts.ScriptTarget.Latest, true);
    const recorder = tree.beginUpdate(path);
    // perform transformations on the various types of imports
    updateImportDeclarations(recorder, sourceFile, from, to);
    updateDynamicImports(recorder, sourceFile, from, to);
    tree.commitUpdate(recorder);
}
/**
 * Update the module specifiers on static imports
 */
function updateImportDeclarations(recorder, sourceFile, from, to) {
    const importDecls = workspace_1.findNodes(sourceFile, ts.SyntaxKind.ImportDeclaration);
    for (const { moduleSpecifier } of importDecls) {
        if (ts.isStringLiteral(moduleSpecifier)) {
            updateModuleSpecifier(recorder, moduleSpecifier, from, to);
        }
    }
}
/**
 * Update the module specifiers on dynamic imports and require statements
 */
function updateDynamicImports(recorder, sourceFile, from, to) {
    const expressions = workspace_1.findNodes(sourceFile, ts.SyntaxKind.CallExpression);
    for (const { expression, arguments: args } of expressions) {
        const moduleSpecifier = args[0];
        // handle dynamic import statements
        if (expression.kind === ts.SyntaxKind.ImportKeyword &&
            moduleSpecifier &&
            ts.isStringLiteral(moduleSpecifier)) {
            updateModuleSpecifier(recorder, moduleSpecifier, from, to);
        }
        // handle require statements
        if (ts.isIdentifier(expression) &&
            expression.text === 'require' &&
            moduleSpecifier &&
            ts.isStringLiteral(moduleSpecifier)) {
            updateModuleSpecifier(recorder, moduleSpecifier, from, to);
        }
    }
}
/**
 * Replace the old module specifier with a the new path
 */
function updateModuleSpecifier(recorder, moduleSpecifier, from, to) {
    if (moduleSpecifier.text === from ||
        moduleSpecifier.text.startsWith(from + '/')) {
        recorder.remove(moduleSpecifier.getStart() + 1, moduleSpecifier.text.length);
        // insert the new module specifier
        recorder.insertLeft(moduleSpecifier.getStart() + 1, moduleSpecifier.text.replace(new RegExp(from, 'g'), to));
    }
}
//# sourceMappingURL=update-imports.js.map